// ╔════════════════════════════════════╗
// ║	Market Sentiment Technicals 	║
// ║	@   Allen.						║
// ║	©   WeloTrades   					║
// ╚════════════════════════════════════╝

//@version=5
indicator(title = 'Smart Money Concepts Plus [Allen]', shorttitle = 'SMC+ [Allen]', overlay = true, max_boxes_count = 500, max_labels_count = 500, max_lines_count = 500, max_bars_back = 5000)


//// ───────────────────────
//  ─── SMC+ ─────────────
//  ─── Colors ─────────────

/// ─── Standard ──
	// color.aqua								= #00BCD4
	// color.blue								= #2196F3
	// color.teal								= #00897B
	// color.green								= #4CAF50
	// color.olive								= #808000
	// color.lime								= #00E676
	// color.yellow								= #FFEB3B
	// color.orange								= #FF9800
	// color.maroon								= #880E4F
	// color.red								= #FF5252
	// color.fuchsia							= #E040FB
	// color.purple								= #9C27B0
	// color.navy								= #311B92
	// color.black								= #363A45
	// color.gray								= #787B86
	// color.silver								= #B2B5BE
	// color.white								= #FFFFFF

/// ─── Ameritrade ───
	// AmeTrWhite								= #FFFFFF								// AmeritradeWhite
	// AmeTrGrayPlatinum						= #F7F7F7								// AmeritradeGrayPlatinum
AmeTrGrayNickel							= #F1F1F1								// AmeritradeGrayNickel
	// AmeTrGrayNickelDark20					= #C0C0C0								// AmeritradeGrayNickelDark20
	// AmeTrGrayAluminum						= #E6E7E9								// AmeritradeGrayAluminum
	// AmeTrGrayAsh								= #D8D8D8								// AmeritradeGrayAsh
	// AmeTrGrayStone							= #999999								// AmeritradeGrayStone
	// AmeTrGrayIron							= #666666								// AmeritradeGrayIron
	// AmeTrGrayCharcoal						= #333333								// AmeritradeGrayCharcoal
	// AmeTrBlack								= #000000								// AmeritradeBlack
	// AmeTrGreenCabbage						= #EBF6E9								// AmeritradeGreenCabbage
	// AmeTrGreenVerdeLight70					= #B4D6B2								// AmeritradeGreenVerdeLight70
	// AmeTrGreenVerdeLight50					= #83BC7F								// AmeritradeGreenVerdeLight50
	// AmeTrGreenVerdeNat						= #40a829								// AmeritradeGreenVerdeNat
	// AmeTrGreenVerdeLight20					= #399333								// AmeritradeGreenVerdeLight20
	// AmeTrGreenVerde							= #087900								// AmeritradeGreenVerde
	// AmeTrGreenVerdeDark20					= #066000								// AmeritradeGreenVerdeDark20
	// AmeTrGreenMoss							= #BEE7D3								// AmeritradeGreenMoss
	// AmeTrGreenMint							= #6DC4BC								// AmeritradeGreenMint
	// AmeTrGreenPine							= #38635A								// AmeritradeGreenPine
	// AmeTrRedRose								= #FAD1CF								// AmeritradeRedRose
	// AmeTrRedRojaLight50						= #E08988								// AmeritradeRedRojaLight50
	// AmeTrRedRojaLight20						= #CD4241								// AmeritradeRedRojaLight20
	// AmeTrRedRoja								= #C11312								// AmeritradeRedRoja
	// AmeTrRedRojaDark20						= #940F0E								// AmeritradeRedRojaDark20
	// AmeTrorangePeach							= #FCE7CA								// AmeritradeorangePeach
	// AmeTrorangeCarrot						= #ED8902								// AmeritradeorangeCarrot
	// AmeTrorangeYam							= #BD5310								// AmeritradeorangeYam
	// AmeTrblueFrost							= #E1EEF9								// AmeritradeblueFrost
	// AmeTrblueLagoon							= #316486								// AmeritradeblueLagoon
	// AmeTrblueNavy							= #2A5673								// AmeritradeblueNavy
	// AmeTrblueNcean							= #64A1C6								// AmeritradeblueNcean
	// AmeTrpurpleEggPlant						= #732181								// AmeritradepurpleEggPlant

/// ─── Axi ───
	// AxiPrimary								= #fc404d								// AxiPrimary
	// AxiSecondary								= #282424								// AxiSecondary
	// AxiAccent								= #61ce70								// AxiAccent
	// Axi7a46f22								= #d11c36								// Axi7a46f22
	// Axi1519066c								= #fc404d								// Axi1519066c
	// Axi3d4fa1a1								= #f0ebe3								// Axi3d4fa1a1
	// Axi638b46c1								= #fcd758								// Axi638b46c1
	// Axid07bac9								= #f9b4a8								// Axid07bac9
	// Axie63a114								= #2c4d5a								// Axie63a114
	// Axi8bf0845								= #a4d866								// Axi8bf0845
	// Axi75c6da1								= #282424								// Axi75c6da1
	// Axi378280f								= #45c2c7								// Axi378280f
	// Axi4de92c5								= #6caddf								// Axi4de92c5
	// Axi413dab8			   					= #00275d					            // Axi413dab8
	// Axib3fab89								= #55165c								// Axib3fab89
	// Axi548138f								= #45c2c7								// Axi548138f
	// Axi5ed9920								= #ea1616								// Axi5ed9920
	// Axi70f7335								= #dd0606								// Axi70f7335

/// ─── GrayScale ───
	// GraySFocus								= #2d7aed								// GrayScaleFocus
	// GraySWhite								= #fff									// GrayScaleWhite
	// GraySBlack								= #000									// GrayScaleBlack
	// GraySPrimaryBlackberry					= #2e234b								// GrayScalePrimaryBlackberry
	// GraySPrimaryBlackberry40					= rgba(46, 35, 75, .4))			    	// GrayScalePrimaryBlackberry40
	// GraySPrimaryBlackberry65					= rgba(46, 35, 75, .65))				// GrayScalePrimaryBlackberry65
	// GraySPrimaryCoral						= #ffb198								// GrayScalePrimaryCoral
	// GraySSecondaryForestGreen				= #244024								// GrayScaleSecondaryForestGreen
	// GraySSecondaryKeyLime					= #b5ce6f								// GrayScaleSecondaryKeyLime
	// GraySSecondaryLavender					= #c5bfe4								// GrayScaleSecondaryLavender
	// GraySSecondaryLavender40					= rgba(197, 191, 228, .4))				// GrayScaleSecondaryLavender40
	// GraySsecondaryLavender60					= rgba(197, 191, 228, .6))				// GrayScalesecondaryLavender60
	// GrayShoverWhite							= #c0bdc9								// GrayScalehoverWhite
	// GrayShoverBlackberry						= #42326b								// GrayScalehoverBlackberry
	// GraySdisabledBlackberry					= #4d4466								// GrayScaledisabledBlackberry
	// GraySactiveBlackberry					= #4d4466								// GrayScaleactiveBlackberry
	// GrayShoverCcoral							= #ffcdbd								// GrayScalehoverCcoral
	// GraySactiveCcoral						= #ff9e80								// GrayScaleactiveCcoral
	// GrayShoverGray							= #827b93								// GrayScalehoverGray
	// GrayShoverGray2							= #6d6581								// GrayScalehoverGray2
	// GraySgrayCharcoal						= #282525								// GrayScalegrayCharcoal
	// GraySgrayCharcoal70						= rgba(40, 37, 37, .7))			    	// GrayScalegrayCharcoal70
	// GraySgrayCharcoal80						= rgba(40, 37, 37, .8))			    	// GrayScalegrayCharcoal80
	// GraySgrayLight							= #f5f5f5								// GrayScalegrayLight
	// GraySgrayMedium							= #eee									// GrayScalegrayMedium
	// GraySgray70								= #696666								// GrayScalegray70
	// GraySgrayDark							= #c1c1c1								// GrayScalegrayDark
	// GraySwebSeasalt		    				= #fafafc								// GrayScalewebSeasalt
	// GraySwebDivider							= #e9e7f1								// GrayScalewebDivider
	// GraySwebBackground						= #f3f2fa								// GrayScalewebBackground
	// GraySwebSecondaryText					= #77708a								// GrayScalewebSecondaryText
	// GraySwebStroke							= #d3ceeb								// GrayScalewebStroke
	// GraySwebErrors							= #e00000								// GrayScalewebErrors
	// GraySwebService							= #2d7aed								// GrayScalewebService

/// ─── Interactive ───
	// IntAcPrimary3							= hsla(355, 85%, 46%, 0.03)		    	// InteractivePrimary3
	// IntAcPrimary5							= hsla(355, 85%, 46%, 0.05)		    	// InteractivePrimary5
	// IntAcPrimary10							= hsla(355, 85%, 46%, 0.10)		    	// InteractivePrimary10
	// IntAcPrimary20							= hsla(355, 85%, 46%, 0.20)		    	// InteractivePrimary20
	// IntAcPrimary30							= hsla(355, 85%, 46%, 0.30)		    	// InteractivePrimary30
	// IntAcPrimary40							= hsla(355, 85%, 46%, 0.40)		    	// InteractivePrimary40
	// IntAcPrimary50							= hsla(355, 85%, 46%, 0.50)		    	// InteractivePrimary50
	// IntAcPrimary60							= hsla(355, 85%, 46%, 0.60)		    	// InteractivePrimary60
	// IntAcPrimary70							= hsla(355, 85%, 46%, 0.70)		    	// InteractivePrimary70
	// IntAcPrimary80							= hsla(355, 85%, 46%, 0.80)		    	// InteractivePrimary80
	// IntAcPrimary90							= hsla(355, 85%, 46%, 0.90)		    	// InteractivePrimary90
	// IntAcPrimary								= hsla(355, 85%, 46%, 1.0)				// InteractivePrimary
	// IntAcPrimaryDark10						= hsla(355, 85%, 41%, 1.0)				// InteractivePrimaryDark10
	// IntAcPrimaryDark20						= hsla(355, 85%, 36%, 1.0)				// InteractivePrimaryDark20
	// IntAcPrimaryDark30						= hsla(355, 85%, 31%, 1.0)				// InteractivePrimaryDark30
	// IntAcPrimaryDark40						= hsla(355, 85%, 26%, 1.0)				// InteractivePrimaryDark40
	// IntAcPrimaryDark50						= hsla(355, 85%, 21%, 1.0)				// InteractivePrimaryDark50
	// IntAcSecondary3							= hsla(0, 0%, 13%, 0.03)				// InteractiveSecondary3
	// IntAcSecondary5							= hsla(0, 0%, 13%, 0.05)				// InteractiveSecondary5
	// IntAcSecondary10							= hsla(0, 0%, 13%, 0.10)				// InteractiveSecondary10
	// IntAcSecondary20							= hsla(0, 0%, 13%, 0.20)				// InteractiveSecondary20
	// IntAcSecondary30							= hsla(0, 0%, 13%, 0.30)				// InteractiveSecondary30
	// IntAcSecondary40							= hsla(0, 0%, 13%, 0.40)				// InteractiveSecondary40
	// IntAcSecondary50							= hsla(0, 0%, 13%, 0.50)				// InteractiveSecondary50
	// IntAcSecondary60							= hsla(0, 0%, 13%, 0.60)				// InteractiveSecondary60
	// IntAcSecondary70							= hsla(0, 0%, 13%, 0.70)				// InteractiveSecondary70
	// IntAcSecondary80							= hsla(0, 0%, 13%, 0.80)				// InteractiveSecondary80
	// IntAcSecondary90							= hsla(0, 0%, 13%, 0.90)				// InteractiveSecondary90
	// IntAcSecondary							= hsla(0, 0%, 13%, 1.0)			    	// InteractiveSecondary
	// IntAcSecondaryDark10						= hsla(0, 0%, 10%, 1.0)			    	// InteractiveSecondaryDark10
	// IntAcSecondaryDark20						= hsla(0, 0%, 7%, 1.0)					// InteractiveSecondaryDark20
	// IntAcSecondaryDark30						= hsla(0, 0%, 4%, 1.0)					// InteractiveSecondaryDark30
	// IntAcSecondaryDark40						= hsla(0, 0%, 1%, 1.0)					// InteractiveSecondaryDark40
	// IntAcSecondaryDark50						= hsla(0, 0%, 0%, 1.0)					// InteractiveSecondaryDark50
	// IntAcTertiary3							= hsla(202, 76%, 19%, 0.03)		    	// InteractiveTertiary3
	// IntAcTertiary5							= hsla(202, 76%, 19%, 0.05)		    	// InteractiveTertiary5
	// IntAcTertiary10							= hsla(202, 76%, 19%, 0.10)		    	// InteractiveTertiary10
	// IntAcTertiary20							= hsla(202, 76%, 19%, 0.20)		    	// InteractiveTertiary20
	// IntAcTertiary30							= hsla(202, 76%, 19%, 0.30)		    	// InteractiveTertiary30
	// IntAcTertiary40							= hsla(202, 76%, 19%, 0.40)		    	// InteractiveTertiary40
	// IntAcTertiary50							= hsla(202, 76%, 19%, 0.50)		    	// InteractiveTertiary50
	// IntAcTertiary60							= hsla(202, 76%, 19%, 0.60)		    	// InteractiveTertiary60
	// IntAcTertiary70							= hsla(202, 76%, 19%, 0.70)		    	// InteractiveTertiary70
	// IntAcTertiary80							= hsla(202, 76%, 19%, 0.80)		    	// InteractiveTertiary80
	// IntAcTertiary90							= hsla(202, 76%, 19%, 0.90)		    	// InteractiveTertiary90
	// IntAcTertiary							= hsla(202, 76%, 19%, 1.0)				// InteractiveTertiary
	// IntAcTertiaryDark10						= hsla(202, 76%, 14%, 1.0)				// InteractiveTertiaryDark10
	// IntAcTertiaryDark20						= hsla(202, 76%, 9%, 1.0)				// InteractiveTertiaryDark20
	// IntAcTertiaryDark30						= hsla(202, 76%, 4%, 1.0)				// InteractiveTertiaryDark30
	// IntAcTertiaryDark40						= hsla(202, 76%, 0%, 1.0)				// InteractiveTertiaryDark40

/// ─── Visa ───
	// VisPrimary								= #1434CB								// VisaBrandPrimary
	// VisPrimaryLight							= #3B57DE								// VisaBrandPrimaryLight
	// VisPrimaryDark							= #021E4C								// VisaBrandPrimaryDark
	// VisSecondary								= #FCC015								// VisaBrandSecondary
	// VisSecondaryLight						= #FFD700								// VisaBrandSecondaryLight
	// VisSecondaryDark							= #F7B600								// VisaBrandSecondaryDark
	// VisTertiary7								= #2C2C2C								// VisaBrandTertiary7
	// VisTertiary6								= #5C5C5C								// VisaBrandTertiary6
	// VisTertiary5								= #979797								// VisaBrandTertiary5
	// VisTertiary4								= #B9B9B9								// VisaBrandTertiary4
	// VisTertiary3								= #DEDEDE								// VisaBrandTertiary3
	// VisTertiary2								= #EEEEEE								// VisaBrandTertiary2
	// VisTertiary1								= #F7F7F7								// VisaBrandTertiary1

/// ─── Latam ───
	// LatRedBackground							= rgb(232, 17, 75)						// Latam Red Background

/// ─── Arbe Robotics ───
ARoPrimary								= #0035FF								// ArbePrimary
ARoPrimaryLight							= #0640FF								// ArbePrimaryLight
	// ARoSecondary		    					= #04ebff								// ArbeSecondary

/// ─── AutoX ───
	// AxPrimary								= #2253F0								// AutoXPrimary
	// AxPrimaryLight							= #0050F9								// AutoXPrimaryLight
	// AxSecondary								= #75ebc0								// AutoXSecondary

/// ─── EEG ───
	// EEGSkyBlue30								= #01EBF9								// EEGSkyBlue30
	// EEGSkyBlue40								= #00E7FD								// EEGSkyBlue40
	// EEGFucsia40								= #FF00B1								// EEGFucsia40
	// EEGFucsia50								= #FE0CB6								// EEGFucsia50

/// ─── Bright Line ───
	// BrLiYel10								= #FBFD73								// BrightLineBackground Yellow Light
BrLiYel20								= #FFFD52								// BrightLine Yellow Light
	// BrLiYel30								= #FDF43C								// BrightLineB Yellow High
BrLiYel40								= #FEF301								// BrightLineBackground Yellow Nit
	// BrLiYel50								= #FFDB00								// BrightLineBackground Yellow Base

/// ─── TradingView ───
	// TVLightMenta50							= #00ffd5								// TradingViewMenta
	// TVLightGreen50					    	= #33ffac								// TradingViewGreenNit
	// TVBlue50									= #0034c5								// TradingViewBlue
	// TVLightYellow50							= #eedd45								// TradingViewYellow
	// TVNitRed40						   		= #e91e63								// TradingViewRedLight
	// TVLightBlueSky50							= #12cef8								// TradingViewBlueSky

/// ─── TFlab ───
	// TFlAsia			    					= #8bbcfc								// Lite TFlabAsia                        
	// TFlSydney		    					= #F0B884								// Lite TFlabSydney                      
	// TFlTokyo									= #0CC1C0								// Lite TFlabTokyo                       
	// TFlShanghai								= #ea1616								// Lite TFlabShanghai                    
	// TFlEuro									= #BBE8B5								// Lite TFlabEuro                        
	// TFlLondon								= #ACBBE8								// Lite TFlabLondon                      
	// TFlNewyork								= #C5ACE8								// Lite TFlabNewyork                     
	// TFlNYSE									= #87c2d4								// Lite TFlabNYSE                        

/// ─── Ultr ───
	// UltrBlueSky10							= #59F2E9								// UltrBlueSky10
	// UltrBlueSky20							= #39F0EA								// UltrBlueSky20
	// UltrMenta10								= #E0F9EF								// UltrMenta10
	// UltrMenta20								= #80F3EC								// UtlrMenta20
	// UltrMenta30								= #7FFFD4								// UltrMenta30
	// UltrMenta40								= #73FFCA								// UltrMenta40
	// UltrMenta50								= #9CFFD7								// UtlrMenta50
	// UltrMenta60								= #4fffc0								// UtlrMenta60
	// UltrRose20								= #ffa3e3								// UltrRose
	// UltrFucsia30								= #ff6fd3								// UltrFucsia
	// UltrLyla									= #7E57C2								// UltrLyla
	// UltrLightGray							= #787B86								// UltrLightGray
	// UltrRedNit								= #de0011								// UltrRedNit
	// UltrRed									= #db004b								// UltrRed
	// UltrBlue									= #003bde								// UltrBlue
	// UltrYellow								= #f4de1a								// UltrYellow
	// UltrSkyBlue								= #12cef8								// UltrSkyBlue
	// UltrOrange								= #ff5a00								// UltrOrange

/// ─── Allen ───
AllenSky10								= #CCF8FF								// AllenSky10
	// AllenSky20								= #80F3EC								// AllenSky20
	// AllenSky50								= #01ebf9								// AllenSky50

	// AllenMint10								= #E0F9EF								// AllenMint10
	// AllenMint20								= #9CFFD7								// AllenMint20
	// AllenMint30								= #7FFFD4								// AllenMint30
	// AllenMint40								= #73FFCA								// AllenMint40
	// AllenMint50								= #4fffc0								// AllenMint50
AllenMint60								= #33ffac								// AllenMint60

AllenWine50								= #e91e63								// AllenWine50

//// ─────────────

//// ───────────────────────
/// ─── OB INPUT SETTINGS
//// ───────────────────────
var grpOBs					= '───── OB SETTINGS ─────'

// OB Settings for multiple timeframes
timeframe1Enabled			= input.bool		(defval = true,			title = "TF #1",				inline = '1',			group = grpOBs)
timeframe1					= input.timeframe	(defval = "",			title = "",						inline = '1',			group = grpOBs)
timeframe2Enabled			= input.bool		(defval = false,		title = "TF #2",				inline = '1',			group = grpOBs)
timeframe2					= input.timeframe	(defval = "",			title = "",						inline = '1',			group = grpOBs,		tooltip="Select Display from Timeframe #1 + select Timeframe / Select Display from Timeframe #2 + select Timeframe")

// Swing OB settings
swingLength					= input.int			(defval = 10,			title = 'Swing OB Length',		inline = '2_',			group = grpOBs,		minval = 3,	display = display.none,	tooltip = "Set the length for Swing OB.")
zoneCount					= input.string		(defval = "5",			title = 'Max OB', 				inline = '2', 			group = grpOBs,		options = ["10", "5", "3", "1"],	display = display.none)
bullOrderBlockColor			= input.color		(color.new(ARoPrimary, 60),			title = '',			inline = '2',			group = grpOBs,		display = display.none)
bearOrderBlockColor			= input.color		(color.new(AllenWine50, 60),		title = '',			inline = '2',			group = grpOBs,		display = display.none,				tooltip = "Select the number of zones for Swing OB / Color for bullish order block / Color for bearish order block.")
obEndMethod					= input.string		(defval = "Close",		title = "Mitigation Method",	inline = '3',			group = grpOBs,		options = ["Wick", "Close"],		display = display.none)
showInvalidated				= input.bool		(defval = false,		title = "historical",			inline = '3',			group = grpOBs,		display = display.none,				tooltip = "Method for OB mitigation / Show invalidated historical OBs.")

// OB box length settings
obBoxLengthOption			= input.string		(defval = "Extended Range",	title = "↔ OB Range",		inline = '4',			group = grpOBs,		options = ["Range", "Extended Range"])
adjustableLength			= input.int			(defval = 22000,		title = "",						inline = '4',			group = grpOBs,		minval = 1000,	maxval = 500000,	step = 1000,	tooltip="Set Length for OB box (extended range = adjustable)")

// OB Text size and individual toggle display boxes
textSizeOption				= input.string		(defval = "S",			title = "Text Options", 		inline = '5',			group = grpOBs,		options = ["XS", "S", "M", "L", "XL"])
textColor					= input.color		(color.new(AmeTrGrayNickel, 75),	title = "",			inline = '5',			group = grpOBs)
showTimeframeOB				= input.bool		(defval = true,			title = "TF Text",				inline = '5',			group = grpOBs)
showVolume					= input.bool		(defval = true,			title = "Volume",				inline = '5',			group = grpOBs)
showPercentage				= input.bool		(defval = true,			title = "%",					inline = '5',			group = grpOBs,		tooltip= "Set Text Size & Color for OB / Toggle Display to show or hide 'TEXT','VOLUME','%'")

// OB locked settings
var grpGENERAL					= '───── GENERAL CONFIGURATION ─────'

OBsEnabled					= true
const bool DEBUG			= false
combineOBs					= DEBUG				? input.bool	(defval = true,		title = "Combine Zones",					group = grpGENERAL,	display = display.none) : true
maxATRMult					= DEBUG				? input.float	(defval = 3.5,		title = "Max Atr Multiplier",				group = grpGENERAL)	: 3.5

bullishOrderBlocks			= zoneCount			== "1"	? 1	: zoneCount == "3" ? 3 : zoneCount == "5" ? 5 : zoneCount == "10" ? 10 : 20
bearishOrderBlocks			= zoneCount			== "1"	? 1	: zoneCount == "3" ? 3 : zoneCount == "5" ? 5 : zoneCount == "10" ? 10 : 20

var grpSTYLE					= '───── STYLE ─────'

extendZonesBy				= DEBUG				? input.int		(defval = 15,		title = "Extend Zones",				inline = "ExtendZones",		group = grpSTYLE,	minval = 1, maxval = 30) : 15
extendZonesDynamic			= DEBUG				? input.bool	(defval = true,		title = "Dynamic",					inline = "ExtendZones",		group = grpSTYLE)	: true
combinedText				= DEBUG				? input.bool	(defval = false,	title = "Combined Text",			inline = "CombinedColor",	group = grpSTYLE)	: false
volumeBarsPlace				= DEBUG				? input.string	(defval = "Left",	title = "Show Volume Bars At",		inline = "volumebars",		group = grpSTYLE,	options = ["Left", "Right"]) : "Left"
mirrorVolumeBars			= DEBUG				? input.bool	(defval = true,		title = "Mirror Volume Bars",		inline = "volumebars",		group = grpSTYLE)	: true
volumeBarsLeftSide			= (volumeBarsPlace	== "Left")
extendZonesByTime			= extendZonesBy		* timeframe.in_seconds(timeframe.period) * 1000
atr = ta.atr(10)

//// ─────────────────────── 
/// ─── FAIR VALUE GAPS INPUT SETTINGS
//// ─────────────────────── 
// FVG Settings for timeframes
var grpFVG					= '───── FAIR VALUE GAPS ─────'

show_fvg					= input				(defval = true,			title = 'FVG TF',				inline = 'tf',			group = grpFVG)
i_tf						= input.timeframe	(defval = "",			title = "" ,					inline = 'tf',			group = grpFVG,		tooltip="Toggle visibility of Fair Value Gaps / Select Timeframe to Display on Chart")

// FVG Settings for Mitigation
mittigation_filt_fvg		= input.string		(defval = 'Wicks',		title = 'Mitigation Method',	inline = "m1",			group = grpFVG,		options = ['Touch','Wicks','Close','Average'])
fvg_color_fill				= input.bool		(defval = true,			title = "Fill" ,				inline = "m1",			group = grpFVG)
fvg_shade_fill				= input.bool		(defval = false,		title = "Shade" ,				inline = "m1",			group = grpFVG,		tooltip = "Select the method to mitigate Fair Value Gaps / Toggle to fill Fair Value Gaps / Toggle to shade Fair Value Gaps")
mid_style					= input.string		(defval = 'Solid',		title = '〰 Line Style',		inline = "mid",			group = grpFVG,		options = ['Solid', 'Dashed', 'Dotted'])
i_midPointColor				= input.color		(color.new(AmeTrGrayNickel, 90),	title = "" ,		inline = "mid",			group = grpFVG,		tooltip = "Select the style for mid line of Fair Value Gaps / Select color for mid line of Fair Value Gaps")

// FVG Count Settings
max_fvg						= input.int			(defval = 5,			title = "Max FVG",				inline = "O1",			group = grpFVG,		minval = 0,	maxval = 50)
i_mtfbearishfvgcolor		= input.color		(color.new(BrLiYel20, 95),			title = "" ,		inline = "O1",			group = grpFVG)
i_mtfbullishfvgcolor		= input.color		(color.new(BrLiYel40, 95),			title = "" ,		inline = "O1",			group = grpFVG,		tooltip="Set the maximum number of Fair Value Gaps to display / Select color for bearish Fair Value Gaps / Select color for bullish Fair Value Gaps")

// FVG Length Settings
length_extend				= input.int			(defval = 20,			title = "↔ FVG Range",			inline = "O2",			group = grpFVG,		minval = 0,	maxval = 100)
fvg_extend					= input.bool		(defval = false,		title = "Extend" ,				inline = "O2",			group = grpFVG)
fvg_extend_B				= input.bool		(defval = true,			title = "Range" ,				inline = "O2",			group = grpFVG,		tooltip="Set the length of Fair Value Gaps / Toggle to extend Fair Value Gaps / Toggle (RANGE) option to extend Fair Value Gaps")

// FVG Filter Settings
max_width_fvg				= input.float		(defval = 1.5,			title = '↕ Max Width',			inline = 'width',		group = grpFVG,		minval = 0, maxval = 5.0, step = 0.1)
remove_small				= input.bool		(defval = true,			title = "Filter FVG" ,			inline = "width",		group = grpFVG,		tooltip="Set the maximum width of Fair Value Gaps / Toggle to filter out small Fair Value Gaps")

//// ─────────────────────── 
/// ─── LIQUIDITY LEVELS INPUT SETTINGS
//// ─────────────────────── 
// Liquidity Settings for timeframes
var grpLIQUID				= '───── LIQUIDITY LEVELS ─────'

currentTF					= input.bool		(defval = true,			title = "Liquidity TF",			inline = "1",			group = grpLIQUID)
htfTF						= input.timeframe	(defval = "",			title = "",						inline = "1",			group = grpLIQUID,		tooltip = "Toggle visibility of Liquidity Levels / Select Timeframe for Liquidity Levels")
leftBars					= input.int			(defval = 10,			title = "Liquidity Length",		inline = "1_",			group = grpLIQUID,		tooltip = "Set the length for Pivot calculation")
displayStyle_liq			= "Boxes"

// Liquidity Buy Side Count Settings
displayLimitBuy				= input.int			(defval = 5,			title = "Max Buy Side Levels",	inline = "2",			group = grpLIQUID)
highLineColorHTF			= input.color		(color.new(AllenWine50, 80),		title = "",			inline = "2",			group = grpLIQUID,		tooltip = "Set the maximum number of Buy Side Liquidity Levels to display / Select color for Buy Side Liquidity Levels")
highBoxBorderColorHTF		= color.new			(AllenWine50, 70)
// highBoxBorderColorHTF		= color.new			(highLineColorHTF, 50)

// Liquidity Sell Side Count Settings
displayLimitSell			= input.int			(defval = 5,			title = "Max Sell Side Levels", inline = "3",			group = grpLIQUID)
lowLineColorHTF				= input.color		(color.new(ARoPrimary, 80),			title = "",			inline = "3",			group = grpLIQUID,		tooltip = "Set the maximum number of Sell Side Liquidity Levels to display / Select color for Sell Side Liquidity Levels")
lowBoxBorderColorHTF		= color.new			(ARoPrimary, 70)
// lowBoxBorderColorHTF		= color.new			(lowLineColorHTF, 50)

// Liquidity Mitigation Settings
mitiOptions					= input.string		(defval = "Remove",		title = "Mitigation Method",	inline = "4",			group = grpLIQUID,		options = ["Remove", "Show"])
_candleType					= input.string		(defval = "Close",		title = "",						inline = '4',			group = grpLIQUID,		options = ["Close", "Wick"],	tooltip ="Select option to display or hide mitigated levels / Select mitigation method")

// Liquidity Box Style Settings
box_width					= input.float		(defval = -5,			title = "Box Style",			inline = "5",			group = grpLIQUID,		minval = -50,	maxval = 50,	step = 0.5)
length_extend_liq			= input.int			(defval = 20,			title = "↔",					inline = "5",			group = grpLIQUID,		minval = 0,		maxval = 500)
extentionMax				= input.bool		(defval = false,		title = "Extend",				inline = "5",			group = grpLIQUID,		tooltip = "Set the box width for liquidity levels / Set the box length of Liquidity Levels / Toggle to extend Liquidity Levels")
_highLineStyleHTF			= "Solid"
highLineStyleHTF			= _highLineStyleHTF == "Solid" ? line.style_solid : _highLineStyleHTF == "Dashed" ? line.style_dashed : line.style_dotted
lineWidthHTF				= 2

// Liquidity Text Style Settings
textSize					= input.string		(defval = "S",			title = "Text Options",			inline = '6',			group = grpLIQUID,		options = ["XS", "S", "M", "L", "XL"])
liquidity_text_color		= input.color		(color.new(AmeTrGrayNickel, 75),	title = '',			inline = '6',			group = grpLIQUID)
show_text					= input.bool		(defval = true,			title = "Text",					inline = '6',			group = grpLIQUID)
show_volume					= input.bool		(defval = true,			title = "Volume",				inline = '6',			group = grpLIQUID)
show_percentage				= input.bool		(defval = true,			title = "%",					inline = '6',			group = grpLIQUID,		tooltip = "Select Size / color for text displaying inside the Liquidity Levels / Toggle Display: Text , Volume , %")

//// ─────────────────────── 
/// ─── BOS & CHOCH MARKET STRUCTURE INPUT SETTINGS
//// ─────────────────────── 
// Internal BOS & CHOCH Settings
var grpMARKETST				= '───── MARKET STRUCTURE ─────'

showInternalMS				= input				(defval = true,			title = "Internal MS Length",			inline = "2",		group = grpMARKETST)
internalLength				= input.int			(defval = 10,			title = "",								inline = "2",		group = grpMARKETST,		tooltip = "Toggle visibility of Internal Market Structure / Set the length for Internal Market Structure")
label_sizes_Internal_		= input.string		(defval = "S",			title = "Internal MS Text Style",		inline = "2_",		group = grpMARKETST,		options = ["S", "M","L"])
internalBullColor			= input.color		(color.new(AllenMint60, 60), title = "",						inline = "2_",		group = grpMARKETST)
internalBearColor			= input.color		(color.new(AmeTrGrayNickel, 60), title = "",					inline = "2_",		group = grpMARKETST,		tooltip = "Set the size of text for Market Structure / Select color for bullish Internal Market Structure / Select color for bearish Internal Market Structure")

label_size_Internal_s		= label_sizes_Internal_ == "S" ? size.tiny : label_sizes_Internal_ == "M" ? size.small : label_sizes_Internal_ == "L" ? size.normal : size.small
label_size_Internal			= label_size_Internal_s

// External BOS(+) & CHOCH(+) Settings  AllenMint60
showExternalMS				= input				(defval = true,			title = "External MS Length",			inline = "3",		group = grpMARKETST)
externalLength				= input.int			(defval = 50,			title = "",								inline = "3",		group = grpMARKETST,		tooltip = "Toggle visibility of External Market Structure / Set the length for External Market Structure")
label_size_External_		= input.string		(defval = "M",			title = "External MS Text Style", 		inline = "3_",		group = grpMARKETST,		options = ["S", "M","L"])
externalBullColor			= input.color		(color.new(AllenMint60, 35),		title = "",					inline = "3_",		group = grpMARKETST)
externalBearColor			= input.color		(color.new(AmeTrGrayNickel, 35),	title = "",					inline = "3_",		group = grpMARKETST,		tooltip = "Set the size of text for Market Structure / Select color for bullish External Market Structure / Select color for bearish External Market Structure")

label_size_External_s		= label_size_External_ == "S" ? size.tiny : label_size_External_ == "M" ? size.small : label_size_External_ == "L" ? size.normal : size.small
label_size_External			= label_size_External_s

// EQH & EQL Settings
show_equal_highlow			= input				(defval = true,			title = 'EQL & EQH Threshold',			inline = '4',		group = grpMARKETST)
eq_threshold				= input.float		(defval = 0.3,			title = '',								inline = '4',		group = grpMARKETST,		minval = 0,		maxval = 10,	step=0.1,		tooltip = "Toggle visibility of Equal Lows & Highs / Set the threshold for Equal Lows & Highs")
label_size_Equal_			= input.string		(defval = "S",			title = "EQL & EQH Text Style", 		inline = "4_",		group = grpMARKETST,		options = ["S", "M","L"])
eq_bull_color				= input.color		(color.new(AllenMint60, 35),		title = '',					inline = "4_",		group = grpMARKETST)
eq_bear_color				= input.color		(color.new(AmeTrGrayNickel, 35),	title = '',					inline = "4_",		group = grpMARKETST,		tooltip="Set the size of text for Equal Lows & Highs / Select color for Equal Lows & Highs")

label_size_Equal_s			= label_size_Equal_ == "S" ? size.tiny : label_size_Equal_ == "M" ? size.small : label_size_Equal_ == "L" ? size.normal : size.small
label_size_Equal			= label_size_Equal_s

// Swing Point Settings
showSwing					= input.bool		(defval = true,			title = 'Swing Points Length',			inline = "1",		group = grpMARKETST)
swingSize_swing				= input.int			(defval = 10,			title = '',								inline = "1",		group = grpMARKETST,		tooltip = "Toggle visibility of Swing Points / Set the length for Swing Points")
label_sizes_swing_			= input.string		(defval = "M",			title = "Swing Points Text Style",		inline = "1_",		group = grpMARKETST,		options = ["S", "M","L"],		tooltip = "Set the size of text for Swing Points / Select color for Swing Points")
swingColor					= input.color		(color.new(AmeTrGrayNickel, 70),	title = '',					inline = "1_",		group = grpMARKETST)
swingSize					= 5
length_eqh					= 5

color CLEAR					= color.rgb(0, 0, 0, 100)
label_size_swing_s			= label_sizes_swing_ == "S" ? size.tiny : label_sizes_swing_ == "M" ? size.small : label_sizes_swing_ == "L" ? size.normal : size.small
label_size_swing			= label_size_swing_s

//// ───────────────────────
/// ─── GLOBAL VARIABLES
//// ───────────────────────

// GLOBAL VARIABLES FUNCTIONS
i_bullishfvgcolor			= color.new(BrLiYel40, 90)
i_bearishfvgcolor			= color.new(BrLiYel40, 90)
i_textColor					= AmeTrGrayNickel
i_fillByMid					= true
i_deleteonfill				= true
i_mtf						= "HTF"
i_tfos						= 10
i_mtfos						= 50
v_buy						= color.new(ARoPrimary, 85)
v_sell						= color.new(AllenWine50, 85)
show_iob					= true 
show_ob						= true 
show_iob_mtf				= true
show_ob_mtf					= true 
ob_showlast					= 10
iob_showlast				= 10
max_width_ob				= 3
max_width_ob				:= max_width_ob == 3 ? 20 : max_width_ob
style						= 'Colored'
v_lookback					= 10
ob_loockback				= 50
timediff					= (time[1] - time[101]) / 100
tf_s1						= timeframe2 == '' ? timeframe.period : timeframe2
timeframe_st				= not(str.contains(tf_s1, 'S')) and not(str.contains(tf_s1, 'D')) and not(str.contains(tf_s1, 'W')) and not(str.contains(tf_s1, 'M')) ? str.tonumber(tf_s1) >= 60 ? str.tostring(str.tonumber(tf_s1) / 60) + "H" : tf_s1 + "M" : tf_s1
color transparent			= #ffffff00
length						= 50
is_newbar(res)				=>
	t             = time(res)
	not na(t) and (na(t[1]) or t > t[1])

Show_MS(x, y, txt, css, dashed, down, lbl_size)=>
	label.new(int(math.avg(x, bar_index)), y, txt, color = transparent, textcolor = css, style = down ? label.style_label_down : label.style_label_up, size = lbl_size)
	line.new(x, y, bar_index, y, color = css, style = dashed ? line.style_dashed : line.style_solid)

f_barssince(_cond, _count) =>
	_barssince = bar_index - ta.valuewhen(_cond, bar_index, _count)
	_barssince

calculate_swing_points(length)=>
	var prev = 0
	prev := high[length] > ta.highest(length) ? 0 : low[length] < ta.lowest(length) ? 1 : prev[1]
	t = prev == 0 and prev[1] != 0 ? high[length] : 0
	b = prev == 1 and prev[1] != 1 ? low[length] : 0
	[t, b]

var t_MS = 0, var int_t_MS = 0
var internal_y_up = 0., var internal_x_up = 0, var internal_y_dn = 0., var internal_x_dn = 0
var y_up = 0., var x_up = 0 , var y_dn = 0., var x_dn = 0
var crossed_up = true,  var crossed_down = true
var internal_up_broke = true, var internal_dn_broke = true
var up_trailing = high, var down_trailing = low
var up_trailing_x = 0,  var down_trailing_x = 0
var high_text = '',  var low_text = ''
bullish_OB_Break = false 
bearish_OB_Break = false

//// ───────────────────────
/// ─── OB CALCULATIONS & FUNCTIONS
//// ───────────────────────
type orderBlockInfo
	float top
	float bottom
	float obVolume
	string obType
	int startTime
	float bbVolume
	float obLowVolume
	float obHighVolume
	bool breaker
	int breakTime
	string timeframeStr
	bool disabled = false
	string combinedTimeframesStr = na
	bool combined = false

type orderBlock
	orderBlockInfo info
	bool isRendered = false

	box orderBox = na
	box breakerBox = na

	line orderBoxLineTop = na
	line orderBoxLineBottom = na
	line breakerBoxLineTop = na
	line breakerBoxLineBottom = na
	
	box orderBoxText = na
	box orderBoxPositive = na
	box orderBoxNegative = na

	line orderSeperator = na
	line orderTextSeperator = na

createOrderBlock (orderBlockInfo orderBlockInfoF) =>
	orderBlock newOrderBlock = orderBlock.new(orderBlockInfoF)
	newOrderBlock

safeDeleteOrderBlock (orderBlock orderBlockF) =>
	orderBlockF.isRendered := false

	box.delete(orderBlockF.orderBox)
	box.delete(orderBlockF.breakerBox)
	box.delete(orderBlockF.orderBoxText)
	box.delete(orderBlockF.orderBoxPositive)
	box.delete(orderBlockF.orderBoxNegative)

	line.delete(orderBlockF.orderBoxLineTop)
	line.delete(orderBlockF.orderBoxLineBottom)
	line.delete(orderBlockF.breakerBoxLineTop)
	line.delete(orderBlockF.breakerBoxLineBottom)
	line.delete(orderBlockF.orderSeperator)
	line.delete(orderBlockF.orderTextSeperator)

type timeframeInfo
	int index = na
	string timeframeStr = na
	bool isEnabled = false

	orderBlockInfo[] bullishOrderBlocksList = na
	orderBlockInfo[] bearishOrderBlocksList = na

newTimeframeInfo (index, timeframeStr, isEnabled) =>
	newTFInfo = timeframeInfo.new()
	newTFInfo.index := index
	newTFInfo.isEnabled := isEnabled
	newTFInfo.timeframeStr := timeframeStr

	newTFInfo

type obSwing
	int x = na    
	float y = na
	float swingVolume = na
	bool crossed = false

const float overlapThresholdPercentage = 0
const int maxDistanceToLastBar = 1750 
const int maxOrderBlocks = 30

var timeframeInfo[] timeframeInfos = array.from(newTimeframeInfo(1, timeframe1, timeframe1Enabled), newTimeframeInfo(2, timeframe2, timeframe2Enabled))
var bullishOrderBlocksList = array.new<orderBlockInfo>(0)
var bearishOrderBlocksList = array.new<orderBlockInfo>(0)
var allOrderBlocksList = array.new<orderBlock>(0)

moveLine(_line, _x, _y, _x2) =>
	line.set_xy1(_line, _x,  _y)
	line.set_xy2(_line, _x2, _y)

moveBox (_box, _topLeftX, _topLeftY, _bottomRightX, _bottomRightY) =>
	box.set_lefttop(_box, _topLeftX, _topLeftY)
	box.set_rightbottom(_box, _bottomRightX, _bottomRightY)

isTimeframeLower (timeframe1F, timeframe2F) =>
	timeframe.in_seconds(timeframe1F) < timeframe.in_seconds(timeframe2F)

getMinTimeframe (timeframe1F, timeframe2F) =>
	if isTimeframeLower(timeframe1F, timeframe2F)
		timeframe1F
	else
		timeframe2F

getMaxTimeframe (timeframe1F, timeframe2F) =>
	if isTimeframeLower(timeframe1F, timeframe2F)
		timeframe2F
	else
		timeframe1F

formatTimeframeString (formatTimeframe) =>
	timeframeF = formatTimeframe == "" ? timeframe.period : formatTimeframe
	
	if str.contains(timeframeF, "D") or str.contains(timeframeF, "W") or str.contains(timeframeF, "S") or str.contains(timeframeF, "M")
		timeframeF
	else
		seconds = timeframe.in_seconds(timeframeF)
		if seconds >= 3600
			hourCount = int(seconds / 3600)
			str.tostring(hourCount) + " Hour" + (hourCount > 1 ? "s" : "")
		else
			timeframeF + " Min"

betterCross(s1, s2) =>
	string ret = na
	if s1 >= s2 and s1[1] < s2
		ret := "Bull"
	if s1 < s2 and s1[1] >= s2
		ret := "Bear"
	ret

colorWithTransparency (colorF, transparencyX) =>
	color.new(colorF, color.t(colorF) * transparencyX)

createOBBox (boxColor, textSize, transparencyX = 1.0, xlocType = xloc.bar_time) =>
	box.new(na, na, na, na, text_size = textSize, xloc = xlocType, extend = extend.none, bgcolor = colorWithTransparency(boxColor, transparencyX), text_color = textColor, text_halign = text.align_center, border_color = #00000000)

getTextSize(textSizeOption) =>
	if textSizeOption == "XS"
		size.tiny
	else if textSizeOption == "S"
		size.small
	else if textSizeOption == "M"
		size.normal    
	else if textSizeOption == "L"
		size.large
	else if textSizeOption == "XL"
		size.huge    


renderOrderBlock (orderBlock ob) =>
	orderBlockInfo info = ob.info
	ob.isRendered := true
	orderColor = ob.info.obType == "Bull" ? bullOrderBlockColor : bearOrderBlockColor

	if OBsEnabled and (not false or not (false and info.breaker)) and not (not showInvalidated and info.breaker)
		textSize = getTextSize(textSizeOption)
		ob.orderBox := createOBBox(orderColor, textSize, 1.5)
		if ob.info.combined
			ob.orderBox.set_bgcolor(colorWithTransparency(orderColor, 1.1))
		ob.orderBoxText := createOBBox(color.new(color.white, 100), textSize)
		if showVolume or showPercentage
			ob.orderBoxPositive := createOBBox(bullOrderBlockColor, textSize)
			ob.orderBoxNegative := createOBBox(bearOrderBlockColor, textSize)
			ob.orderSeperator := line.new(na,na,na,na,xloc.bar_time,extend.none,textColor,line.style_dashed,1)
			ob.orderTextSeperator := line.new(na,na,na,na,xloc.bar_time,extend.none,textColor,line.style_solid,1)

		zoneSize = if obBoxLengthOption == "Range"
			time - info.startTime 
		else if obBoxLengthOption == "Extended Range"
			time - info.startTime + adjustableLength * timeframe.in_seconds(timeframe.period)
		else
			extendZonesByTime
		
		startX = volumeBarsLeftSide ? info.startTime : info.startTime + zoneSize - zoneSize / 3
		maxEndX = volumeBarsLeftSide ? info.startTime + zoneSize / 3 : info.startTime + zoneSize

		moveBox(ob.orderBox, info.startTime, info.top, info.startTime + zoneSize, info.bottom)
		moveBox(ob.orderBoxText, volumeBarsLeftSide ? maxEndX : info.startTime, info.top, volumeBarsLeftSide ? info.startTime + zoneSize : startX, info.bottom)

		percentage = int((math.min(info.obHighVolume, info.obLowVolume) / math.max(info.obHighVolume, info.obLowVolume)) * 100.0)
		OBText = (na(ob.info.combinedTimeframesStr) ? formatTimeframeString(ob.info.timeframeStr) : ob.info.combinedTimeframesStr) + " OB"
		textToDisplay = ""
		if showTimeframeOB
			textToDisplay += OBText + " "
		if showVolume
			textToDisplay += str.tostring(ob.info.obVolume, format.volume) + " "
		if showPercentage
			textToDisplay += "(" + str.tostring(percentage) + "%)"

		box.set_text(ob.orderBoxText, textToDisplay)

		if showVolume or showPercentage
			showHighLowBoxText = false

			curEndXHigh = int(math.ceil((info.obHighVolume / info.obVolume) * (maxEndX - startX) + startX))
			curEndXLow = int(math.ceil((info.obLowVolume / info.obVolume) * (maxEndX - startX) + startX))

			moveBox(ob.orderBoxPositive, mirrorVolumeBars ? startX : curEndXLow, info.top, mirrorVolumeBars ? curEndXHigh : maxEndX, (info.bottom + info.top) / 2)
			box.set_text(ob.orderBoxPositive, showHighLowBoxText ? str.tostring(info.obHighVolume, format.volume) : "")

			moveBox(ob.orderBoxNegative, mirrorVolumeBars ? startX : curEndXHigh, info.bottom, mirrorVolumeBars ? curEndXLow : maxEndX, (info.bottom + info.top) / 2)
			box.set_text(ob.orderBoxNegative, showHighLowBoxText ? str.tostring(info.obLowVolume, format.volume) : "")

			moveLine(ob.orderSeperator, volumeBarsLeftSide ? startX : maxEndX, (info.bottom + info.top) / 2, volumeBarsLeftSide ? maxEndX : startX)

			line.set_xy1(ob.orderTextSeperator, volumeBarsLeftSide ? maxEndX : startX, info.top)
			line.set_xy2(ob.orderTextSeperator, volumeBarsLeftSide ? maxEndX : startX, info.bottom)

findOBSwings(len) =>
	var swingType = 0
	var obSwing top = obSwing.new(na, na)
	var obSwing bottom = obSwing.new(na, na)
	
	upper = ta.highest(len)
	lower = ta.lowest(len)

	swingType := high[len] > upper ? 0 : low[len] < lower ? 1 : swingType

	if swingType == 0 and swingType[1] != 0
		top := obSwing.new(bar_index[len], high[len], volume[len])
	
	if swingType == 1 and swingType[1] != 1
		bottom := obSwing.new(bar_index[len], low[len], volume[len])

	[top, bottom]

findOrderBlocks () =>
	if bar_index > last_bar_index - maxDistanceToLastBar
		[top, btm] = findOBSwings(swingLength)
		useBody = false
		max = useBody ? math.max(close, open) : high
		min = useBody ? math.min(close, open) : low

		// Bullish Order Block
		bullishBreaked = 0

		if array.size(bullishOrderBlocksList) > 0
			for i = array.size(bullishOrderBlocksList) - 1 to 0
				currentOB = array.get(bullishOrderBlocksList, i)
			
				if not na(currentOB) and not currentOB.breaker 
					if (obEndMethod == "Wick" ? low : math.min(open, close)) < currentOB.bottom
						currentOB.breaker := true
						currentOB.breakTime := time
						currentOB.bbVolume := volume
				else
					if not na(currentOB) and high > currentOB.top
						array.remove(bullishOrderBlocksList, i)
					else if not na(currentOB) and i < bullishOrderBlocks and top.y < currentOB.top and top.y > currentOB.bottom 
						bullishBreaked := 1

		if close > top.y and not top.crossed
			top.crossed := true

			boxBtm = max[1]
			boxTop = min[1]
			boxLoc = time[1]

			for i = 1 to (bar_index - top.x) - 1
				boxBtm := math.min(min[i], boxBtm)
				boxTop := boxBtm == min[i] ? max[i] : boxTop
				boxLoc := boxBtm == min[i] ? time[i] : boxLoc

			newOrderBlockInfo = orderBlockInfo.new(boxTop, boxBtm, volume + volume[1] + volume[2], "Bull", boxLoc)
			newOrderBlockInfo.obLowVolume := volume[2]
			newOrderBlockInfo.obHighVolume := volume + volume[1]
			
			obSize = math.abs(newOrderBlockInfo.top - newOrderBlockInfo.bottom)
			if obSize <= atr * maxATRMult
				array.unshift(bullishOrderBlocksList, newOrderBlockInfo)
				if array.size(bullishOrderBlocksList) > maxOrderBlocks
					array.pop(bullishOrderBlocksList)

		// Bearish Order Block
		bearishBreaked = 0

		if array.size(bearishOrderBlocksList) > 0
			for i = array.size(bearishOrderBlocksList) - 1 to 0
				currentOB = array.get(bearishOrderBlocksList, i)

				if not na(currentOB) and not currentOB.breaker 
					if (obEndMethod == "Wick" ? high : math.max(open, close)) > currentOB.top
						currentOB.breaker := true
						currentOB.breakTime := time
						currentOB.bbVolume := volume
				else
					if not na(currentOB) and low < currentOB.bottom
						array.remove(bearishOrderBlocksList, i)
					else if not na(currentOB) and i < bearishOrderBlocks and btm.y > currentOB.bottom and btm.y < currentOB.top 
						bearishBreaked := 1

		if close < btm.y and not btm.crossed
			btm.crossed := true

			boxBtm = min[1]
			boxTop = max[1]
			boxLoc = time[1]

			for i = 1 to (bar_index - btm.x) - 1
				boxTop := math.max(max[i], boxTop)
				boxBtm := boxTop == max[i] ? min[i] : boxBtm
				boxLoc := boxTop == max[i] ? time[i] : boxLoc

			newOrderBlockInfo = orderBlockInfo.new(boxTop, boxBtm, volume + volume[1] + volume[2], "Bear", boxLoc)
			newOrderBlockInfo.obLowVolume := volume + volume[1]
			newOrderBlockInfo.obHighVolume := volume[2]

			obSize = math.abs(newOrderBlockInfo.top - newOrderBlockInfo.bottom)
			if obSize <= atr * maxATRMult
				array.unshift(bearishOrderBlocksList, newOrderBlockInfo)
				if array.size(bearishOrderBlocksList) > maxOrderBlocks
					array.pop(bearishOrderBlocksList)
	true

areaOfOB (orderBlockInfo OBInfoF) =>
	float XA1 = OBInfoF.startTime
	float XA2 = na(OBInfoF.breakTime) ? time + 1 : OBInfoF.breakTime
	float YA1 = OBInfoF.top
	float YA2 = OBInfoF.bottom
	float edge1 = math.sqrt((XA2 - XA1) * (XA2 - XA2) + (YA2 - YA2) * (YA2 - YA2))
	float edge2 = math.sqrt((XA2 - XA2) * (XA2 - XA2) + (YA2 - YA1) * (YA2 - YA1))
	float totalArea = edge1 * edge2
	totalArea

doOBsTouch (orderBlockInfo OBInfo1, orderBlockInfo OBInfo2) =>
	float XA1 = OBInfo1.startTime
	float XA2 = na(OBInfo1.breakTime) ? time + 1 : OBInfo1.breakTime
	float YA1 = OBInfo1.top
	float YA2 = OBInfo1.bottom

	float XB1 = OBInfo2.startTime
	float XB2 = na(OBInfo2.breakTime) ? time + 1 : OBInfo2.breakTime
	float YB1 = OBInfo2.top
	float YB2 = OBInfo2.bottom
	float intersectionArea = math.max(0, math.min(XA2, XB2) - math.max(XA1, XB1)) * math.max(0, math.min(YA1, YB1) - math.max(YA2, YB2))
	float unionArea = areaOfOB(OBInfo1) + areaOfOB(OBInfo2) - intersectionArea
	
	float overlapPercentage = (intersectionArea / unionArea) * 100.0

	if overlapPercentage > overlapThresholdPercentage
		true
	else
		false

isOBValid (orderBlockInfo OBInfo) =>
	valid = true
	if OBInfo.disabled
		valid := false
	valid

combineOBsFunc () =>
	if array.size(allOrderBlocksList) > 0
		lastCombinations = 999
		while lastCombinations > 0
			lastCombinations := 0
			for i = 0 to array.size(allOrderBlocksList) - 1
				curOB1 = array.get(allOrderBlocksList, i)
				for j = 0 to array.size(allOrderBlocksList) - 1
					curOB2 = array.get(allOrderBlocksList, j)
					if i == j
						continue
					if not isOBValid(curOB1.info) or not isOBValid(curOB2.info)
						continue
					if curOB1.info.obType != curOB2.info.obType
						continue
					if doOBsTouch(curOB1.info, curOB2.info)
						curOB1.info.disabled := true
						curOB2.info.disabled := true
						orderBlock newOB = createOrderBlock(orderBlockInfo.new(math.max(curOB1.info.top, curOB2.info.top), math.min(curOB1.info.bottom, curOB2.info.bottom), curOB1.info.obVolume + curOB2.info.obVolume, curOB1.info.obType))
						newOB.info.startTime := math.min(curOB1.info.startTime, curOB2.info.startTime)
						newOB.info.breakTime := math.max(nz(curOB1.info.breakTime), nz(curOB2.info.breakTime))
						newOB.info.breakTime := newOB.info.breakTime == 0 ? na : newOB.info.breakTime
						newOB.info.timeframeStr := curOB1.info.timeframeStr

						newOB.info.obVolume := curOB1.info.obVolume + curOB2.info.obVolume
						newOB.info.obLowVolume := curOB1.info.obLowVolume + curOB2.info.obLowVolume
						newOB.info.obHighVolume := curOB1.info.obHighVolume + curOB2.info.obHighVolume
						newOB.info.bbVolume := nz(curOB1.info.bbVolume, 0) + nz(curOB2.info.bbVolume, 0)
						newOB.info.breaker := curOB1.info.breaker or curOB2.info.breaker
						
						newOB.info.combined := true
						if timeframe.in_seconds(curOB1.info.timeframeStr) != timeframe.in_seconds(curOB2.info.timeframeStr)
							newOB.info.combinedTimeframesStr := (na(curOB1.info.combinedTimeframesStr) ? formatTimeframeString(curOB1.info.timeframeStr) : curOB1.info.combinedTimeframesStr) + " & " + (na(curOB2.info.combinedTimeframesStr) ? formatTimeframeString(curOB2.info.timeframeStr) : curOB2.info.combinedTimeframesStr)
						array.unshift(allOrderBlocksList, newOB)
						lastCombinations += 1

reqSeq (timeframeStr) =>
	[bullishOrderBlocksListF, bearishOrderBlocksListF] = request.security(syminfo.tickerid, timeframeStr, [bullishOrderBlocksList, bearishOrderBlocksList])
	[bullishOrderBlocksListF, bearishOrderBlocksListF]

getTFData (timeframeInfo timeframeInfoF, timeframeStr) =>
	if timeframeInfoF.isEnabled
		[bullishOrderBlocksListF, bearishOrderBlocksListF] = reqSeq(timeframeStr)
		if na(bullishOrderBlocksListF) or na(bearishOrderBlocksListF)
			[array.new<orderBlockInfo>(0), array.new<orderBlockInfo>(0)]
		else
			[bullishOrderBlocksListF, bearishOrderBlocksListF]
	else
		[array.new<orderBlockInfo>(0), array.new<orderBlockInfo>(0)]

handleTimeframeInfo (timeframeInfo timeframeInfoF, bullishOrderBlocksListF, bearishOrderBlocksListF) =>
	if timeframeInfoF.isEnabled
		if not na(bullishOrderBlocksListF)
			timeframeInfoF.bullishOrderBlocksList := bullishOrderBlocksListF
		else
			timeframeInfoF.bullishOrderBlocksList := array.new<orderBlockInfo>(0)
		if not na(bearishOrderBlocksListF)
			timeframeInfoF.bearishOrderBlocksList := bearishOrderBlocksListF
		else
			timeframeInfoF.bearishOrderBlocksList := array.new<orderBlockInfo>(0)

handleOrderBlocksFinal () =>
	if DEBUG
		log.info("Bullish OB Count " + str.tostring(array.size(bullishOrderBlocksList)))
		log.info("Bearish OB Count " + str.tostring(array.size(bearishOrderBlocksList)))

	if array.size(allOrderBlocksList) > 0
		for i = 0 to array.size(allOrderBlocksList) - 1
			safeDeleteOrderBlock(array.get(allOrderBlocksList, i))
	array.clear(allOrderBlocksList)    

	for i = 0 to array.size(timeframeInfos) - 1
		curTimeframe = array.get(timeframeInfos, i)
		if not curTimeframe.isEnabled
			continue
		if not na(curTimeframe.bullishOrderBlocksList) and array.size(curTimeframe.bullishOrderBlocksList) > 0
			for j = 0 to math.min(array.size(curTimeframe.bullishOrderBlocksList) - 1, bullishOrderBlocks - 1)
				orderBlockInfoF = array.get(curTimeframe.bullishOrderBlocksList, j)
				orderBlockInfoF.timeframeStr := curTimeframe.timeframeStr
				array.unshift(allOrderBlocksList, createOrderBlock(orderBlockInfo.copy(orderBlockInfoF)))

		if not na(curTimeframe.bearishOrderBlocksList) and array.size(curTimeframe.bearishOrderBlocksList) > 0
			for j = 0 to math.min(array.size(curTimeframe.bearishOrderBlocksList) - 1, bearishOrderBlocks - 1)
				orderBlockInfoF = array.get(curTimeframe.bearishOrderBlocksList, j)
				orderBlockInfoF.timeframeStr := curTimeframe.timeframeStr
				array.unshift(allOrderBlocksList, createOrderBlock(orderBlockInfo.copy(orderBlockInfoF)))

	if combineOBs
		combineOBsFunc()    

	if array.size(allOrderBlocksList) > 0
		for i = 0 to array.size(allOrderBlocksList) - 1
			curOB = array.get(allOrderBlocksList, i)
			if isOBValid(curOB.info)
				renderOrderBlock(curOB)

findOrderBlocks()

[bullishOrderBlocksListTimeframe1, bearishOrderBlocksListTimeframe1] = getTFData(array.get(timeframeInfos, 0), timeframe1)
[bullishOrderBlocksListTimeframe2, bearishOrderBlocksListTimeframe2] = getTFData(array.get(timeframeInfos, 1), timeframe2)

if barstate.isconfirmed
	handleTimeframeInfo(array.get(timeframeInfos, 0), bullishOrderBlocksListTimeframe1, bearishOrderBlocksListTimeframe1)
	handleTimeframeInfo(array.get(timeframeInfos, 1), bullishOrderBlocksListTimeframe2, bearishOrderBlocksListTimeframe2)
	handleOrderBlocksFinal()

//// ───────────────────────
/// ─── FAIR VALUE GAPS CALCULATIONS & FUNCTIONS
//// ───────────────────────
lineStyle(x) =>
	switch x
		'Solid' => line.style_solid
		'Dashed' => line.style_dashed
		'Dotted' => line.style_dotted
// FAIR VALUE GAPS FUNCTION //
var htfH = open
var htfL = open

if close > htfH 
	htfH:= close
if close < htfL
	htfL := close

sClose  = request.security(ticker.standard(syminfo.tickerid), i_tf, close[1], barmerge.gaps_off, barmerge.lookahead_on)
sHighP2 = request.security(ticker.standard(syminfo.tickerid), i_tf, high[2], barmerge.gaps_off, barmerge.lookahead_on)
sLowP2  = request.security(ticker.standard(syminfo.tickerid), i_tf, low[2], barmerge.gaps_off, barmerge.lookahead_on)
sOpen   = request.security(ticker.standard(syminfo.tickerid), i_tf, open[1], barmerge.gaps_off, barmerge.lookahead_on)
sBar    = request.security(ticker.standard(syminfo.tickerid), i_tf, bar_index, barmerge.gaps_off, barmerge.lookahead_on)
var bullishgapholder = array.new_box(0)
var bearishgapholder = array.new_box(0)
var bullishgapholder_fill = array.new_box(0)
var bearishgapholder_fill = array.new_box(0)
var bullish_high_holder = array.new_line(0)
var bearish_high_holder = array.new_line(0)
var bullish_low_holder  = array.new_line(0)
var bearish_low_holder  = array.new_line(0)
var bullishmidholder    = array.new_line(0)
var bearishmidholder    = array.new_line(0)
var bullishlabelholder  = array.new_label(0)
var bearishlabelholder  = array.new_label(0)
var transparentcolor    = color.new(color.white,100)
var fvg_apper=false
var fvg_break=false
fvg_apper:=false
fvg_break:=false

create_fvg_func(_upperlimit,_lowerlimit,_midlimit,_bar,_boxholder,_boxholder_fill,_midholder,_highholder,_lowholder,_labelholder,_boxcolor,_mtfboxcolor, _htf)=>
	timeholder = str.tostring(i_tf)
	offset = i_mtfos
	boxbgcolor = _mtfboxcolor
	bg_color = color.new(_mtfboxcolor,90)
	if _htf == false
		timeholder := str.tostring(timeframe.period)
		offset := i_tfos
		boxbgcolor := _boxcolor
	array.push(_boxholder,box.new(_bar,_upperlimit,_bar+(timediff)*length_extend,_lowerlimit,border_color=fvg_color_fill? bg_color : na,bgcolor = fvg_color_fill? bg_color : na, extend = fvg_extend ? extend.right:extend.none,xloc = xloc.bar_time,text='',text_color=#787b86,text_halign=text.align_right,text_size=size.small))
	array.push(_boxholder_fill,box.new(_bar,_upperlimit,_bar+(timediff)*length_extend,_lowerlimit,border_color=fvg_color_fill? bg_color : na ,bgcolor = fvg_color_fill? bg_color : na, extend = fvg_extend ? extend.right:extend.none,xloc = xloc.bar_time))
	array.push(_midholder,line.new(_bar,(_lowerlimit+_upperlimit)/2.0,_bar+(timediff)*length_extend,_midlimit,color = i_midPointColor, extend = fvg_extend ? extend.right:extend.none,style=lineStyle(mid_style),width=1,xloc = xloc.bar_time))
	array.push(_lowholder,line.new(_bar,_lowerlimit,_bar+(timediff)*length_extend,_lowerlimit,color = i_fillByMid?boxbgcolor:na, extend = fvg_extend ? extend.right:extend.none,width=1,xloc = xloc.bar_time))
	array.push(_highholder,line.new(_bar,_upperlimit,_bar+(timediff)*length_extend,_upperlimit,color = i_fillByMid?boxbgcolor:na, extend = fvg_extend ? extend.right:extend.none,width=1,xloc = xloc.bar_time))

//checks for gap //
check_fvg_func(_close,_high,_highp2,_low,_lowp2,_open,_bar,_htf)=>
	gap=0
	thold_ = (ta.highest(_high,300) - ta.lowest(_low,300)) * math.max(max_width_fvg, 0.1) / 100.
	if _open > _close // red

		if _lowp2>_high
			if not(remove_small) or math.abs(_lowp2 -_high) > thold_
				upperlimit = _high
				lowerlimit = _lowp2
				midlimit = lowerlimit + ((upperlimit - lowerlimit) / 2.)
				gap:=1
				create_fvg_func(upperlimit,lowerlimit,midlimit,_bar,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder,i_bullishfvgcolor,i_mtfbullishfvgcolor,_htf)
			
	else
		
		if _low>_highp2
			if not(remove_small) or math.abs(_low - _highp2) > thold_
				upperlimit = _low
				lowerlimit = _highp2
				midlimit = lowerlimit + ((upperlimit - lowerlimit) / 2.)
				gap:=-1
				create_fvg_func(upperlimit,lowerlimit,midlimit,_bar,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder,i_bearishfvgcolor,i_mtfbearishfvgcolor,_htf)
			
	gap

// MITIGATION FAIR VALUE GAPS
delete_fvg_func(_currentgap,_currentgap_fill,_i,_boxholder,_boxholder_fill,_midholder,_highholder,_lowholder,_labelholder)=>
   
	array.remove(_boxholder,_i)
	array.remove(_boxholder_fill,_i)
	currentmid=array.get(_midholder,_i)
	currenthigh=array.get(_highholder,_i)
	currentlow=array.get(_lowholder,_i)
	array.remove(_midholder,_i)
	array.remove(_highholder,_i)
	array.remove(_lowholder,_i)
	
	if i_deleteonfill
		line.delete(currentmid)
		line.delete(currenthigh)
		line.delete(currentlow)
	else
		line.set_extend(currentmid, extend.none)
		line.set_x2(currentmid,time)
		line.set_extend(currenthigh, extend.none)
		line.set_x2(currenthigh,time)
		line.set_extend(currentlow, extend.none)
		line.set_x2(currentlow,time)

	if i_deleteonfill
		box.delete(_currentgap)
		box.delete(_currentgap_fill)
				
	else
		box.set_extend(_currentgap,extend.none)
		box.set_right(_currentgap,time)

// CHECKS FILLED FAIR VALUE GAPS
validate_fvg_func(_high,_low)=>

	fvg_removed=0
	if array.size(bullishgapholder) > 0

		for i = array.size(bullishgapholder)-1 to 0
			if fvg_extend_B
				currentgap_fill = array.get(bullishgapholder_fill,i)
				currentgap = array.get(bullishgapholder,i)
				cmid = array.get(bullishmidholder,i)
				chigh = array.get(bullish_high_holder,i)
				clow = array.get(bullish_low_holder,i)
				line.set_x2(cmid,timenow+(timediff)*length_extend)
				line.set_x2(chigh,timenow+(timediff)*length_extend)
				line.set_x2(clow,timenow+(timediff)*length_extend)
				box.set_right(currentgap_fill,timenow+(timediff)*length_extend)
				box.set_right(currentgap,timenow+(timediff)*length_extend)

			if mittigation_filt_fvg=='Touch'
				currentgap_fill = array.get(bullishgapholder_fill,i)
				currentgap = array.get(bullishgapholder,i)
				currentmid = array.get(bullishmidholder,i)
				currenthigh = array.get(bullish_high_holder,i)
				currentlow = array.get(bullish_low_holder,i)
				currenttop = box.get_top(currentgap)

				if high > currenttop
					fvg_removed:=1
					delete_fvg_func(currentgap,currentgap_fill,i,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder)
			
			if mittigation_filt_fvg=='Wicks'
				currentgap_fill = array.get(bullishgapholder_fill,i)
				currentgap = array.get(bullishgapholder,i)
				currentmid = array.get(bullishmidholder,i)
				currenthigh = array.get(bullish_high_holder,i)
				currentlow = array.get(bullish_low_holder,i)
				currenttop = box.get_bottom(currentgap)
				currentbottom = box.get_top(currentgap_fill)

				if high > currentbottom and fvg_shade_fill
					currentgap_f = array.get(bullishgapholder_fill,i)
					cur_bottom=box.get_bottom(currentgap_f)
					_bottom=box.get_bottom(currentgap)
					if _bottom==cur_bottom
						box.set_bottom(currentgap_f,high)
					else
						box.set_bottom(currentgap_f,math.max(cur_bottom,high))
					box.set_bgcolor(currentgap_f,#787b865e)
					
				if high > currenttop
					fvg_removed:=1
					delete_fvg_func(currentgap,currentgap_fill,i,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder)
			
			if mittigation_filt_fvg=='Close'
				currentgap_fill = array.get(bullishgapholder_fill,i)
				currentgap = array.get(bullishgapholder,i)
				currentmid = array.get(bullishmidholder,i)
				currenthigh = array.get(bullish_high_holder,i)
				currentlow = array.get(bullish_low_holder,i)
				currenttop = box.get_bottom(currentgap)
				currentbottom = box.get_top(currentgap_fill)

				if high > currentbottom and fvg_shade_fill
					currentgap_f = array.get(bullishgapholder_fill,i)
					cur_bottom=box.get_bottom(currentgap_f)
					_bottom=box.get_bottom(currentgap)
					if _bottom==cur_bottom
						box.set_bottom(currentgap_f,high)
					else
						box.set_bottom(currentgap_f,math.max(cur_bottom,high))
					box.set_bgcolor(currentgap_f,#787b865e)
				if close > currenttop
					fvg_removed:=1
					delete_fvg_func(currentgap,currentgap_fill,i,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder)

			if mittigation_filt_fvg=='Average'
				currentgap_fill = array.get(bullishgapholder_fill,i)
				currentgap = array.get(bullishgapholder,i)
				currentmid = array.get(bullishmidholder,i)
				currenthigh = array.get(bullish_high_holder,i)
				currentlow = array.get(bullish_low_holder,i)
				currenttop = line.get_y1(currentmid)
				currentbottom = box.get_top(currentgap_fill)

				if high > currentbottom and fvg_shade_fill
					currentgap_f = array.get(bullishgapholder_fill,i)
					cur_bottom=box.get_bottom(currentgap_f)
					_bottom=box.get_bottom(currentgap)
					if _bottom==cur_bottom
						box.set_bottom(currentgap_f,high)
					else
						box.set_bottom(currentgap_f,math.max(cur_bottom,high))
					box.set_bgcolor(currentgap_f,#787b865e)

				if high > currenttop
					fvg_removed:=1
					delete_fvg_func(currentgap,currentgap_fill,i,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder)

	if array.size(bearishgapholder) > 0
			
		for i = array.size(bearishgapholder)-1 to 0
			if fvg_extend_B
				currentgap_fill = array.get(bearishgapholder_fill,i)
				currentgap = array.get(bearishgapholder,i)
				cmid = array.get(bearishmidholder,i)
				chigh = array.get(bearish_high_holder,i)
				clow = array.get(bearish_low_holder,i)
				line.set_x2(cmid,timenow+(timediff)*length_extend)
				line.set_x2(chigh,timenow+(timediff)*length_extend)
				line.set_x2(clow,timenow+(timediff)*length_extend)
				box.set_right(currentgap_fill,timenow+(timediff)*length_extend)
				box.set_right(currentgap,timenow+(timediff)*length_extend)

			if mittigation_filt_fvg=='Touch'
				currentgap_fill = array.get(bearishgapholder_fill,i)
				currentgap = array.get(bearishgapholder,i)
				currenttop = box.get_top(currentgap)
				currentmid = array.get(bearishmidholder,i)
				currenthigh = array.get(bearish_high_holder,i)
				currentlow = array.get(bearish_low_holder,i)
	
				if low < currenttop
					fvg_removed:=-1
					delete_fvg_func(currentgap,currentgap_fill,i,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder)
			if mittigation_filt_fvg=='Wicks'
				currentgap_fill = array.get(bearishgapholder_fill,i)
				currentgap = array.get(bearishgapholder,i)
				currenttop = box.get_bottom(currentgap)
				currentmid = array.get(bearishmidholder,i)
				currenthigh = array.get(bearish_high_holder,i)
				currentlow = array.get(bearish_low_holder,i)
				currentbottom = box.get_top(currentgap_fill)

				if low < currentbottom and fvg_shade_fill
					currentgap_f = array.get(bearishgapholder_fill,i)
					cur_bottom=box.get_bottom(currentgap_f)
					_bottom=box.get_bottom(currentgap)
					if _bottom==cur_bottom
						box.set_bottom(currentgap_f,low)
					else
						box.set_bottom(currentgap_f,math.min(cur_bottom,low))
					box.set_bgcolor(currentgap_f,#787b865e)

				if low < currenttop
					fvg_removed:=-1
					delete_fvg_func(currentgap,currentgap_fill,i,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder)
			if mittigation_filt_fvg=='Close'
				currentgap_fill = array.get(bearishgapholder_fill,i)
				currentgap = array.get(bearishgapholder,i)
				currenttop = box.get_bottom(currentgap)
				currentmid = array.get(bearishmidholder,i)
				currenthigh = array.get(bearish_high_holder,i)
				currentlow = array.get(bearish_low_holder,i)
				currentbottom = box.get_top(currentgap_fill)

				if low < currentbottom and fvg_shade_fill
					currentgap_f = array.get(bearishgapholder_fill,i)
					cur_bottom=box.get_bottom(currentgap_f)
					_bottom=box.get_bottom(currentgap)
					if _bottom==cur_bottom
						box.set_bottom(currentgap_f,low)
					else
						box.set_bottom(currentgap_f,math.min(cur_bottom,low))
					box.set_bgcolor(currentgap_f,#787b865e)

				if close < currenttop
					fvg_removed:=-1
					delete_fvg_func(currentgap,currentgap_fill,i,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder)
			if mittigation_filt_fvg=='Average'
				currentgap_fill = array.get(bearishgapholder_fill,i)
				currentgap = array.get(bearishgapholder,i)
				currentmid = array.get(bearishmidholder,i)
				currenttop = line.get_y1(currentmid)
				currenthigh = array.get(bearish_high_holder,i)
				currentlow = array.get(bearish_low_holder,i)
				currentbottom = box.get_top(currentgap_fill)

				if low < currentbottom and fvg_shade_fill
					currentgap_f = array.get(bearishgapholder_fill,i)
					cur_bottom=box.get_bottom(currentgap_f)
					_bottom=box.get_bottom(currentgap)
					if _bottom==cur_bottom
						box.set_bottom(currentgap_f,low)
					else
						box.set_bottom(currentgap_f,math.min(cur_bottom,low))
					box.set_bgcolor(currentgap_f,#787b865e)

				if low < currenttop
					fvg_removed:=-1
					delete_fvg_func(currentgap,currentgap_fill,i,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder)

	fvg_removed
				
// FUNCTION DETRMINE NEW BAR
if is_newbar(i_tf)
	htfH := high
	htfL := low

fvg_gap=0


if array.size(bullishgapholder) > max_fvg
	d_box=array.shift(bullishgapholder)
	box.delete(d_box)

if array.size(bullishgapholder_fill) > max_fvg
	d_box=array.shift(bullishgapholder_fill)
	box.delete(d_box)

if array.size(bullishmidholder) > max_fvg
	d_line=array.shift(bullishmidholder)
	line.delete(d_line)

if array.size(bullish_high_holder) > max_fvg
	d_line=array.shift(bullish_high_holder)
	line.delete(d_line)

if array.size(bullish_low_holder) > max_fvg
	d_line=array.shift(bullish_low_holder)
	line.delete(d_line)

if array.size(bearishgapholder) > max_fvg
	d_box_=array.shift(bearishgapholder)
	box.delete(d_box_)

if array.size(bearishgapholder_fill) > max_fvg
	d_box_=array.shift(bearishgapholder_fill)
	box.delete(d_box_)

if array.size(bearishmidholder) > max_fvg
	d_line_=array.shift(bearishmidholder)
	line.delete(d_line_)

if array.size(bearish_high_holder) > max_fvg
	d_line_=array.shift(bearish_high_holder)
	line.delete(d_line_)

if array.size(bearish_low_holder) > max_fvg
	d_line_=array.shift(bearish_low_holder)
	line.delete(d_line_)
	
n=bar_index
fvg_removed=validate_fvg_func(high,low)


//// ───────────────────────
/// ─── LIQUIDITY LEVELS CALCULATIONS & FUNCTIONS
//// ───────────────────────
highLineColor      = highLineColorHTF
lowLineColor       = lowLineColorHTF
highBoxBgColor     = highLineColorHTF
highBoxBorderColor = highBoxBorderColorHTF
lowBoxBgColor      = lowLineColorHTF
lowBoxBorderColor  = lowBoxBorderColorHTF
atr_liq            = ta.atr(300)
float thold_liq    = atr_liq * (box_width / 10)

tf_multi(tf) =>
	ts       = timeframe.in_seconds("")
	htfs     = timeframe.in_seconds(tf)
	htfs     / ts

display_limit_lines(_array, _limit) =>
	while array.size(_array) > _limit
		line.delete(array.shift(_array))

display_limit_boxes(_array, _limit) =>
	while array.size(_array) > _limit
		box.delete(array.shift(_array))

remove_mitigated_lines(_array, _hl, _candleType, _mitiOptions, _lineColor, _lineStyle, _lineWidth, _displayLimit) =>
	m = false
	if array.size(_array) > 0      
		for i  = array.size(_array) - 1 to 0 by 1
			l  = array.get(_array, i)
			hh = _candleType == "Close" ? close[1] : high
			ll = _candleType == "Close" ? close[1] : low
			if _hl == "High" and hh > line.get_y1(l)
				array.remove(_array, i)
				if _mitiOptions == "Show"
					line.new(line.get_x1(l), line.get_y1(l), time, line.get_y1(l), xloc = xloc.bar_time, color = _lineColor, style = _lineStyle, width = _lineWidth)
				line.delete(l)
				m := true
			if _hl == "Low" and ll < line.get_y1(l)
				array.remove(_array, i)
				if _mitiOptions == "Show"
					line.new(line.get_x1(l), line.get_y1(l), time, line.get_y1(l), xloc = xloc.bar_time, color = _lineColor, style = _lineStyle, width = _lineWidth)
				line.delete(l) 
				m := true  
	display_limit_lines(_array, _displayLimit) 
	m

remove_mitigated_boxes(_array, _hl, _candleType, _mitiOptions, _bgColor, _borderColor, _lineStyle, _lineWidth, _displayLimit) =>
	m = false
	if array.size(_array) > 0
		for i  = array.size(_array) - 1 to 0 by 1
			l  = array.get(_array, i)
			hh = _candleType == "Close" ? close[1] : high
			ll = _candleType == "Close" ? close[1] : low
			if _hl == "High" and hh > box.get_top(l)
				array.remove(_array, i)
				if _mitiOptions == "Show"
					box.new(box.get_left(l), box.get_top(l), time, box.get_bottom(l), xloc = xloc.bar_time, bgcolor = color.new(_bgColor, 90), border_color = color.new(_borderColor, 90), border_style = _lineStyle, border_width = _lineWidth)
				box.delete(l)
				m := true
			if _hl == "Low" and ll < box.get_top(l)
				array.remove(_array, i)
				if _mitiOptions == "Show"
					box.new(box.get_left(l), box.get_top(l), time, box.get_bottom(l), xloc = xloc.bar_time, bgcolor = color.new(_bgColor, 90), border_color = color.new(_borderColor, 90), border_style = _lineStyle, border_width = _lineWidth)
				box.delete(l)
				m := true
	display_limit_boxes(_array, _displayLimit) 
	m

extend_line_to_current(lineArray, _length_extend, _timediff) =>
	if array.size(lineArray) > 0
		for i = array.size(lineArray) - 1 to 0 by 1
			l = array.get(lineArray, i)
			timeExt = timenow + ((_timediff) * _length_extend)
			line.set_x2(l, timeExt)

extend_box_to_current(boxArray, _length_extend, _timediff) =>
	if array.size(boxArray) > 0
		for i = array.size(boxArray) - 1 to 0 by 1
			b = array.get(boxArray, i)
			timeExt = timenow + ((_timediff) * _length_extend)
			box.set_right(b, timeExt)

var highLineArrayHTF = array.new_line()
var lowLineArrayHTF  = array.new_line()  
var highBoxArrayHTF  = array.new_box()
var lowBoxArrayHTF   = array.new_box()

[_time, _open, _high, _low, _close, vol] = request.security(syminfo.tickerid, htfTF, [time, open, high, low, close, volume])

pivotHighHTF  = ta.pivothigh(_high, leftBars * tf_multi(htfTF), leftBars + tf_multi(htfTF))
pivotLowHTF   = ta.pivotlow(_low, leftBars * tf_multi(htfTF), leftBars + tf_multi(htfTF))

timeExt      = time + ((time[1] - time[2]) * 10)
dis          = leftBars + tf_multi(htfTF)

label_size_external = switch textSize
	"XS"   => size.tiny
	"S"  => size.small
	"M" => size.normal
	"L"  => size.large
	"XL"   => size.huge

highest_volume    = ta.highest(vol, 300)
volume_percentage = (vol / highest_volume) * 100

format_volume(vol) =>
	vol >= 1000000000 ? str.tostring(vol / 1000000000, '#.##') + "B" : vol >= 1000000 ? str.tostring(vol / 1000000, '#.##') + "M" : str.tostring(vol / 1000, '#.##') + "K"

// Function to format the timeframe string
format_tf(tf) =>
	tf == "1" ? "1Min" :tf == "2" ? "2Min" : tf == "3" ? "3Min" : tf == "5" ? "5Min" : tf == "10" ? "10Min" : tf == "15" ? "15Min" : tf == "30" ? "30Min" : tf == "45" ? "45Min" : tf == "60" ? "1H" : tf == "120" ? "2H" : tf == "180" ? "3H" : tf == "240" ? "4H" :  tf == "D" ? "1D" : tf == "W" ? "1W" : tf == "M" ? "1M" :  tf == "M" ? "3M" :tf == "M" ? "6M" : tf == "Y" ? "1Y" : tf

if currentTF
	if pivotHighHTF
		if displayStyle_liq == "Lines"
			array.push(highLineArrayHTF, line.new(_time[dis], _high[dis], _time[+1], _high[dis], color = highLineColorHTF, style = highLineStyleHTF, xloc = xloc.bar_time, extend = extentionMax ? extend.right : extend.none, width = lineWidthHTF))
		else
			y1 = _high[dis] - thold_liq
			volume_text = (htfTF == "" ? "" : "(" + format_tf(htfTF) + ") ") + "Buy Side 💲"
			if show_volume
				volume_text := volume_text + format_volume(vol)
			if show_percentage
				volume_text := volume_text + " (" + str.tostring(volume_percentage, '#.##') + "%)"
			if not show_text
				volume_text := ""
			array.push(highBoxArrayHTF, box.new(_time[dis], _high[dis], _time[+1], y1, bgcolor = highLineColorHTF, border_color = highBoxBorderColorHTF, xloc = xloc.bar_time, border_style = highLineStyleHTF, extend = extentionMax ? extend.right : extend.none, border_width = lineWidthHTF, text = volume_text, text_halign = text.align_center, text_color = liquidity_text_color, text_size = label_size_external))
			display_limit_boxes(highBoxArrayHTF, displayLimitBuy)
			
	if pivotLowHTF
		if displayStyle_liq == "Lines"
			array.push(lowLineArrayHTF, line.new(_time[dis], _low[dis], _time[+1], _low[dis], color = lowLineColorHTF, style = highLineStyleHTF, xloc = xloc.bar_time, extend = extentionMax ? extend.right : extend.none, width = lineWidthHTF))
		else
			y1 = _low[dis] + thold_liq
			volume_text = (htfTF == "" ? "" : "(" + format_tf(htfTF) + ") ") + "Sell Side 💲"
			if show_volume
				volume_text := volume_text + format_volume(vol)
			if show_percentage
				volume_text := volume_text + " (" + str.tostring(volume_percentage, '#.##') + "%)"
			if not show_text
				volume_text := ""
			array.push(lowBoxArrayHTF, box.new(_time[dis], _low[dis], _time[+1], y1, bgcolor = lowLineColorHTF, border_color = lowBoxBorderColorHTF, xloc = xloc.bar_time, border_style = highLineStyleHTF, extend = extentionMax ? extend.right : extend.none, border_width = lineWidthHTF, text = volume_text, text_halign = text.align_center, text_color = liquidity_text_color, text_size = label_size_external))
			display_limit_boxes(lowBoxArrayHTF, displayLimitSell)

// Extend and remove old lines and boxes
extend_line_to_current(highLineArrayHTF, length_extend_liq, timediff)
extend_line_to_current(lowLineArrayHTF, length_extend_liq, timediff)
extend_box_to_current(highBoxArrayHTF, length_extend_liq, timediff)
extend_box_to_current(lowBoxArrayHTF, length_extend_liq, timediff)

//// ───────────────────────
/// ─── MARKET STRUCTURE CALCULATIONS & FUNCTION
//// ───────────────────────
bosConfType      = 'Candle High'
CHOCH            = true
pivot_high_found = ta.pivothigh(high, swingSize_swing, swingSize_swing)
pivot_low_found  = ta.pivotlow(low, swingSize_swing, swingSize_swing)

var float prevHigh_s = na, var float prevLow_s = na, var int prevHighIndex_s = na, var int prevLowIndex_s = na
bool higher_highs = false, bool lower_highs = false, bool higher_lows = false, bool lower_lows = false

var int prevSwing_s = 0

if not na(pivot_high_found)
	if pivot_high_found >= prevHigh_s
		higher_highs := true
		prevSwing_s := 2
	else
		lower_highs := true
		prevSwing_s := 1
	prevHigh_s := pivot_high_found
	prevHighIndex_s := bar_index - swingSize_swing

if not na(pivot_low_found)
	if pivot_low_found >= prevLow_s
		higher_lows := true
		prevSwing_s := -1
	else
		lower_lows := true
		prevSwing_s := -2
	prevLow_s := pivot_low_found
	prevLowIndex_s := bar_index - swingSize_swing

if higher_highs and showSwing
	label.new(bar_index - swingSize_swing, pivot_high_found, 'HH', color=CLEAR, style=label.style_label_down, textcolor=swingColor, size=label_size_swing_s)
if lower_highs and showSwing
	label.new(bar_index - swingSize_swing, pivot_high_found, 'LH', color=CLEAR, style=label.style_label_down, textcolor=swingColor, size=label_size_swing_s)
if higher_lows and showSwing
	label.new(bar_index - swingSize_swing, pivot_low_found, 'HL', color=CLEAR, style=label.style_label_up, textcolor=swingColor, size=label_size_swing_s)
if lower_lows and showSwing
	label.new(bar_index - swingSize_swing, pivot_low_found, 'LL', color=CLEAR, style=label.style_label_up, textcolor=swingColor, size=label_size_swing_s)

// EQH & EQL
atr_ = ta.atr(200)
var high_eqh_pre = 0., var eq_top_x = 0, var low_eqh_pre = 0., var eq_btm_x = 0

if show_equal_highlow
	high_eqh = ta.pivothigh(length_eqh, length_eqh)
	low_eqh  = ta.pivotlow(length_eqh, length_eqh)
	if not na(low_eqh) 
		if math.min(low_eqh, low_eqh_pre) > math.max(low_eqh, low_eqh_pre) - atr_ * eq_threshold
			eql_line = line.new(eq_btm_x, low_eqh_pre, n-length_eqh, low_eqh, color=eq_bull_color, style=line.style_dotted)
			eql_lbl  = label.new(int(math.avg(n-length_eqh, eq_btm_x)), low_eqh, 'EQL', color=#00000000, textcolor=eq_bull_color, style=label.style_label_up, size=label_size_Equal_s)
		low_eqh_pre := low_eqh
		eq_btm_x    := n-length_eqh
	if not na(high_eqh)     
		if math.max(high_eqh, high_eqh_pre) < math.min(high_eqh, high_eqh_pre) + atr_ * eq_threshold
			eqh_line = line.new(eq_top_x, high_eqh_pre, n-length_eqh, high_eqh, color=eq_bear_color, style=line.style_dotted)
			eqh_lbl  = label.new(int(math.avg(n-length_eqh, eq_top_x)), high_eqh, 'EQH', color=#00000000, textcolor=eq_bear_color, style=label.style_label_down, size=label_size_Equal_s)
		high_eqh_pre:= high_eqh
		eq_top_x    := n-length_eqh

[high_ms, low_ms] = calculate_swing_points(externalLength)
n := bar_index

// HL OUTPUT FUNCTION
hl() => [high, low]
var float thold = (ta.highest(300) - ta.lowest(300)) * math.max(0.5, 0.1) / 100.
[int_high_ms, int_low_ms] = calculate_swing_points(internalLength)
if low_ms
	crossed_down := true
	y_dn := low_ms
	x_dn := n - externalLength
if high_ms
	crossed_up := true
	y_up := high_ms
	x_up := n - externalLength
if int_low_ms
	internal_dn_broke := true
	internal_y_dn := int_low_ms
	internal_x_dn := n - internalLength
if int_high_ms
	internal_up_broke := true
	internal_y_up := int_high_ms
	internal_x_up := n - internalLength
bull_CHOCH = false, bull_CHOCH_ = false, bull_bos = false, bull_bos_ = false, bear_CHOCH = false, bear_CHOCH_ = false, bear_bos = false, bear_bos_ = false
if ta.crossover(close, internal_y_up) and internal_up_broke and y_up != internal_y_up
	bool MSS = na
	CHOCH := int_t_MS < 0
	internal_up_broke := false
	int_t_MS := 1
	bull_CHOCH := CHOCH ? true : false
	bull_bos := CHOCH ? false : true
	if showInternalMS
		Show_MS(internal_x_up, internal_y_up, CHOCH ? 'CHOCH' : 'BOS', internalBullColor, true, true, label_size_Internal_s)
if ta.crossunder(close, internal_y_dn) and internal_dn_broke and y_dn != internal_y_dn 
	bool MSS = false
	CHOCH := int_t_MS > 0    
	internal_dn_broke := false
	int_t_MS := -1
	bear_CHOCH := CHOCH ? true : false
	bear_bos := CHOCH ? false : true
	if showInternalMS
		Show_MS(internal_x_dn, internal_y_dn, CHOCH ? 'CHOCH' : 'BOS', internalBearColor, true, false, label_size_Internal_s)

if ta.crossover(close, y_up) and crossed_up
	bool MSS = na
	MSS := t_MS < 0
	crossed_up := false
	t_MS := 1
	bull_CHOCH_ := MSS ? true : false
	bull_bos_ := MSS ? false : true
	if showExternalMS
		Show_MS(x_up, y_up, MSS ? 'CHOCH+' : 'BOS+', externalBullColor, false, true, label_size_External_s)
if ta.crossunder(close, y_dn) and crossed_down
	bool MSS = na
	MSS := t_MS > 0
	crossed_down := false
	t_MS := -1
	bear_CHOCH_ := MSS ? true : false
	bear_bos_ := MSS ? false : true
	if showExternalMS
		Show_MS(x_dn, y_dn, MSS ? 'CHOCH+' : 'BOS+', externalBearColor, false, false, label_size_External_s)

//// ───────────────────────
/// ─── ALERTS
//// ───────────────────────
// FVG ALERTS //
if is_newbar(i_tf) and (i_mtf == "Current + HTF" or i_mtf == "HTF") and show_fvg and barstate.isconfirmed
	fvg_gap:=check_fvg_func(sClose,htfH,sHighP2,htfL,sLowP2,sOpen,time[2],true)
	
alertcondition(fvg_gap==1,"Bullish FVG","Bullish FVG Found")
alertcondition(fvg_gap==-1,"Bearish FVG","Bearish FVG Found")

// LIQUIDITY ALERTS //
alertcondition(remove_mitigated_lines(highLineArrayHTF, "High", _candleType, mitiOptions, highLineColorHTF, highLineStyleHTF, lineWidthHTF, displayLimitBuy) or remove_mitigated_boxes(highBoxArrayHTF, "High", _candleType, mitiOptions, highBoxBgColor, highBoxBorderColorHTF, highLineStyleHTF, lineWidthHTF, displayLimitBuy), "Internal Buy Side Liquidity Level Break", "Internal Buy Side Liquidity Level Broken")
alertcondition(remove_mitigated_lines(lowLineArrayHTF, "Low", _candleType, mitiOptions, lowLineColorHTF, highLineStyleHTF, lineWidthHTF, displayLimitSell) or remove_mitigated_boxes(lowBoxArrayHTF, "Low", _candleType, mitiOptions, lowBoxBgColor, lowBoxBorderColorHTF, highLineStyleHTF, lineWidthHTF, displayLimitSell), "Internal Sell Side Liquidity Level Break", "Internal Sell Side Liquidity Level Broken")

// MARKET STRUCTURE ALERTS //
alertcondition(bull_CHOCH, "Bullish CHOCH", 'Bullish CHOCH Found ')
alertcondition(bear_CHOCH, "Bearish CHOCH", 'Bearish CHOCH Found ')
alertcondition(bull_bos, "Bullish BOS", 'Bullish BOS Found ')
alertcondition(bear_bos, "Bearish BOS", 'Bearish BOS Found ')

alertcondition(bull_CHOCH_, "Bullish CHOCH+", 'Bullish CHOCH+ Found')
alertcondition(bear_CHOCH_, "Bearish CHOCH+", 'Bearish CHOCH+ Found')
alertcondition(bear_bos_, "Bearish BOS+", 'Bearish BOS+ Found')
alertcondition(bull_bos_, "Bullish BOS+", 'Bullish BOS+ Found')

//// ─────────────────────── 
